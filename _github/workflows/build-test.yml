# ==============================================================================
# 🚀 Build & Test CI - Main CI/CD Pipeline
# ==============================================================================
# 
# Purpose: Complete CI/CD pipeline for C++ projects with comprehensive testing
# 
# Features:
# • Matrix-based builds (Debug/Release configurations)
# • Multi-compiler support with reusable workflow orchestration
# • Comprehensive testing pipeline (unit tests → integration tests)
# • Advanced caching strategies for faster CI runs
# • JUnit XML test reporting with GitHub UI integration
# • Artifact uploads for debugging failures
# • Downstream compatibility validation
# 
# Workflow Architecture:
# 1. setup → Sets up C++ environment using setup-env.yml
# 2. build → Compiles project using cmake-build.yml (includes setup-env.yml automatically)
# 3. unit-tests → Runs Google Test suite using cached build artifacts
# 4. integration-tests → Validates downstream package consumption
# 
# Usage:
# • Automatically triggers on push and pull_request events
# • Uses reusable workflows for modularity and maintainability
# • Optimized for C++ projects using CMake presets and vcpkg
# • Provides comprehensive test coverage and failure diagnostics
# ==============================================================================

name: 🚀 Build & Test CI

on:
  push:
    branches:
      - '**'  # All branches
#    tags-ignore:
#      - '**'  # Exclude all tags
#  pull_request:

jobs:
  # ==============================================================================
  # Environment Setup Job - Prepares C++ Toolchain
  # ==============================================================================
  # Uses reusable setup-env.yml workflow to establish consistent build environment
  # across all matrix configurations. Provides compiler toolchain, ccache, and vcpkg.
  setup:
    name: ⚙️ Setup • ${{ matrix.buildType == 'debug' && 'Debug' || 'Release' }} • ${{ matrix.compiler == 'gcc' && 'GCC' || 'Clang' }}
    uses: ./.github/workflows/setup-env.yml
    with:
      compiler: ${{ matrix.compiler }}
      enable-ccache: true
      ccache-size: '1G'
      install-vcpkg: true
    
    strategy:
      matrix:
        buildType: [debug, release]  # Lowercase to match CMakePresets.json preset names
        compiler: [gcc]  # Multi-compiler support

  # ==============================================================================
  # Build Job - Compiles C++ Project with CMake
  # ==============================================================================
  # Uses reusable cmake-build.yml workflow to handle CMake configuration and build.
  # Supports both preset-based and traditional CMake workflows with optimizations.
  build:
    name: 🔨 Build • ${{ matrix.buildType == 'debug' && 'Debug' || 'Release' }} • ${{ matrix.compiler == 'gcc' && 'GCC' || 'Clang' }}
    needs: setup
    uses: ./.github/workflows/cmake-build.yml
    with:
      compiler: ${{ matrix.compiler }}
      buildType: ${{ matrix.buildType }}
      cmake-preset: ${{ matrix.buildType }}  # Use presets from CMakePresets.json
      build-preset: ${{ matrix.buildType }}
    secrets: inherit
    
    strategy:
      matrix:
        buildType: [debug, release]  # Lowercase to match CMakePresets.json preset names
        compiler: [gcc]  # Multi-compiler support

  # ==============================================================================
  # Unit Tests Job - Runs Google Test Suite with JUnit Reporting
  # ==============================================================================
  # Executes comprehensive unit tests with matrix strategy across build configurations.
  # Features JUnit XML generation for GitHub UI integration and artifact uploads.
  unit-tests:
    name: 🧪 Tests • ${{ matrix.buildType == 'debug' && 'Debug' || 'Release' }} • ${{ matrix.compiler == 'gcc' && 'GCC' || 'Clang' }}
    needs: build
    runs-on: ubuntu-22.04
    timeout-minutes: 25
    
    strategy:
      matrix:
        buildType: [debug, release]  # Lowercase to match CMakePresets.json preset names
        compiler: [gcc]  # Multi-compiler support

    steps:
      # Checkout source code with full history for comprehensive testing
      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Full history needed for proper git operations

      # Restore cached build directory from the build job
      # Uses commit-specific cache keys to ensure artifacts from the current build
      - name: Cache Build Directory
        id: cache-build
        uses: actions/cache@v4
        with:
          path: build
          key: build-${{ matrix.compiler }}-${{ matrix.buildType }}-${{ github.sha }}-${{ github.run_id }}
          restore-keys: |
            build-${{ matrix.compiler }}-${{ matrix.buildType }}-${{ github.sha }}-
            build-${{ matrix.compiler }}-${{ matrix.buildType }}-
            build-${{ matrix.compiler }}-

      # Download build artifacts as primary method for inter-job artifact sharing
      # Always attempts download to ensure we have the latest build artifacts
      - name: Download Build Artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.buildType }}-${{ matrix.compiler }}
          path: build/
        continue-on-error: true  # Don't fail immediately, let verification step provide better error

      # Check artifact download status and provide helpful error messages
      - name: Check Artifact Download Status
        if: steps.download-artifacts.outcome == 'failure'
        run: |
          echo "❌ Failed to download build artifacts"
          echo "   Artifact name: build-artifacts-${{ matrix.buildType }}-${{ matrix.compiler }}"
          echo "   This suggests either:"
          echo "   1. The build job failed and didn't upload artifacts"
          echo "   2. There's a naming mismatch between upload and download"
          echo "   3. The build job didn't complete before this job started"
          echo ""
          echo "🔍 Check the build job logs for errors or failures"
          exit 1

      # Verify that build artifacts exist and are valid
      # This ensures the build completed successfully before running tests
      - name: Verify Build Artifacts
        run: |
          # ==============================================================================
          # Verify Build Artifacts from Build Job
          # ==============================================================================
          echo "🔍 Checking for build artifacts from build job..."
          
          # Check for build directories (presets may create subdirectories)
          BUILD_DIR=""
          if [[ -d "build/${{ matrix.buildType }}" ]]; then
            BUILD_DIR="build/${{ matrix.buildType }}"
            echo "📁 Using preset-specific build directory: $BUILD_DIR"
          elif [[ -d "build" ]]; then
            BUILD_DIR="build"
            echo "📁 Using standard build directory: $BUILD_DIR"
          else
            echo "❌ No build directory found"
            echo "   Expected: build/ or build/${{ matrix.buildType }}/ directory from build job"
            echo "   This suggests artifact download failed or build job didn't complete"
            echo "   Current directory contents:"
            ls -la . || true
            exit 1
          fi
          
          # Check for CMake cache file (indicates successful configuration)
          if [[ ! -f "$BUILD_DIR/CMakeCache.txt" ]]; then
            echo "❌ CMakeCache.txt not found in $BUILD_DIR"
            echo "   This suggests CMake configuration failed in build job"
            echo "   Build directory contents:"
            ls -la "$BUILD_DIR/" || true
            exit 1
          fi
          
          echo "✅ Build artifacts successfully restored from build job"
          echo "📁 Build directory: $BUILD_DIR"
          ls -la "$BUILD_DIR/" || true
          echo "🔧 CMake configuration verified - ready for testing"

      # Execute unit tests using ctest with matrix configuration
      # Supports both JUnit XML output (CMake 3.21+) and standard output
      - name: Run Unit Tests
        run: |
          # ==============================================================================
          # Execute Unit Tests with Comprehensive Reporting
          # ==============================================================================
          # Determine build directory structure
          BUILD_DIR=""
          if [[ -d "build/${{ matrix.buildType }}" ]]; then
            BUILD_DIR="build/${{ matrix.buildType }}"
            echo "📁 Running tests from preset-specific directory: $BUILD_DIR"
          elif [[ -d "build" ]]; then
            BUILD_DIR="build"
            echo "📁 Running tests from standard directory: $BUILD_DIR"
          else
            echo "❌ No build directory found for testing"
            exit 1
          fi
          
          # Change to build directory for testing
          cd "$BUILD_DIR"
          
          # Verify that tests were built and are available
          if ! ctest --show-only=json-v1 2>/dev/null | grep -q '"name"'; then
            echo "⚠️  No tests found in build directory"
            echo "   This might mean BUILD_TESTING=OFF in the preset or tests weren't built"
            echo "   Available CTest targets:"
            ctest --show-only 2>/dev/null || echo "   No CTest configuration found"
            exit 0  # Exit successfully but skip test execution
          fi
          
          echo "📋 Found tests to execute:"
          ctest --show-only --quiet
          
          # Check if ctest supports --output-junit for better GitHub integration
          if ctest --help | grep -q "output-junit"; then
            echo "Using JUnit output for better GitHub UI integration"
            XML_FILE="test-results-${{ matrix.buildType }}-${{ matrix.compiler }}.xml"
            
            # Run tests and generate XML output
            if ctest --output-on-failure --output-junit "$XML_FILE"; then
              echo "✅ Tests completed successfully with JUnit XML output"
            else
              echo "❌ Tests failed but JUnit XML output was generated"
              exit 1
            fi
            
            # Move XML file to workspace root for artifact upload
            if [[ -f "$XML_FILE" ]]; then
              mv "$XML_FILE" "../$XML_FILE"
              echo "📄 JUnit XML moved to workspace root: ../$XML_FILE"
            else
              echo "⚠️  JUnit XML file not found: $XML_FILE"
            fi
          else
            echo "CMake version does not support --output-junit, using standard output"
            ctest --output-on-failure
            # Create empty XML file to prevent upload failures
            touch "../test-results-${{ matrix.buildType }}-${{ matrix.compiler }}.xml"
          fi
          
          # Return to workspace root
          cd ..
        
      # Verify JUnit XML file exists before upload and reporting
      - name: Verify Test Results File
        id: verify-xml
        run: |
          XML_FILE="test-results-${{ matrix.buildType }}-${{ matrix.compiler }}.xml"
          if [[ -f "$XML_FILE" ]] && [[ -s "$XML_FILE" ]]; then
            echo "✅ JUnit XML file found and not empty: $XML_FILE"
            echo "file-exists=true" >> $GITHUB_OUTPUT
            echo "📄 File size: $(stat -c%s "$XML_FILE") bytes"
            echo "📋 File preview:"
            head -n 10 "$XML_FILE" || true
          else
            echo "⚠️  JUnit XML file missing or empty: $XML_FILE"
            echo "file-exists=false" >> $GITHUB_OUTPUT
            echo "📁 Current directory contents:"
            ls -la . || true
          fi

      # Upload JUnit XML test results for GitHub UI integration
      # Always runs to capture results even on test failures
      - name: Upload Test Results
        if: always() && steps.verify-xml.outputs.file-exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.buildType }}-${{ matrix.compiler }}
          path: test-results-${{ matrix.buildType }}-${{ matrix.compiler }}.xml
          if-no-files-found: warn

      # Publish test results to GitHub PR with annotations and summary
      # Provides rich test reporting directly in the GitHub UI
      - name: Publish Test Results
        if: always() && steps.verify-xml.outputs.file-exists == 'true'
        uses: dorny/test-reporter@v2
        with:
          name: Unit Tests (${{ matrix.buildType }} - ${{ matrix.compiler }})
          path: test-results-${{ matrix.buildType }}-${{ matrix.compiler }}.xml
          reporter: java-junit
          fail-on-error: false  # Don't fail workflow if test reporting fails

      # Upload detailed test logs for debugging failed tests
      # Only uploads on failure to reduce artifact storage usage
      - name: Upload Test Logs (on failure)
        if: failure()
        timeout-minutes: 5
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-logs-${{ matrix.buildType }}-${{ matrix.compiler }}
          path: |
            build/**/Testing/**/*.log
            build/${{ matrix.buildType }}/**/Testing/**/*.log
          if-no-files-found: warn

  # ==============================================================================
  # Integration Tests Job - Downstream Compatibility Validation
  # ==============================================================================
  # Validates that the library can be consumed by downstream projects using find_package().
  # Tests all 8 configurations (Debug/Release × Static/Shared × 2 build types) to ensure
  # comprehensive compatibility across different usage patterns and build configurations.
  integration-tests:
    name: 🔗 Integration • Debug • GCC
    needs: [setup, unit-tests]
    runs-on: ubuntu-22.04
    timeout-minutes: 45
    
    env:
      BUILD_TYPE: debug  # Environment variable for debug-only integration tests (lowercase for consistency)

    steps:
      # Checkout source code with full history for integration testing
      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Full history needed for comprehensive integration tests

      # Setup compiler environment for integration tests (GCC debug only)
      # Integration tests require a separate environment setup due to extensive rebuilding
      - name: Restore Environment from Setup Job
        run: |
          # ==============================================================================
          # Restore Environment from Setup Job (GCC Debug Only)
          # ==============================================================================
          # Integration tests reuse environment from the setup job to eliminate duplication
          echo "CC=gcc-12" >> $GITHUB_ENV
          echo "CXX=g++-12" >> $GITHUB_ENV  
          echo "/usr/lib/ccache" >> $GITHUB_PATH

      # Install essential build tools for integration testing
      # Quick installation leveraging apt cache from previous jobs
      - name: Install Build Tools (Quick)
        timeout-minutes: 5
        run: |
          # ==============================================================================
          # Install Essential Tools (Lightweight Installation)
          # ==============================================================================
          # Quick install leveraging apt cache from previous jobs
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build gcc-12 g++-12 ccache

      # Cache vcpkg packages specifically for integration tests
      # Uses dedicated cache key for debug configuration
      - name: Cache vcpkg Packages
        uses: actions/cache@v4
        with:
          path: |
            ${{ runner.temp }}/vcpkg/installed
            ${{ runner.temp }}/vcpkg/buildtrees
          key: vcpkg-gcc-debug-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-gcc-debug-
            vcpkg-gcc-
            vcpkg-

      # Setup vcpkg for downstream compatibility testing
      # Integration tests require vcpkg to test package consumption scenarios
      - name: Setup vcpkg
        timeout-minutes: 15
        uses: ./.github/actions/setup-vcpkg
        with:
          vcpkgDirectory: ${{ runner.temp }}/vcpkg

      # Execute comprehensive downstream compatibility tests
      # Tests all 8 configurations: Debug/Release × Static/Shared × 2 build types
      - name: Run Downstream Compatibility Tests (Debug only)
        run: |
          # ==============================================================================
          # Execute Comprehensive Downstream Compatibility Testing
          # ==============================================================================
          echo "Running integration tests with BUILD_TYPE: $BUILD_TYPE"
          echo "Integration tests use debug configuration for comprehensive downstream validation"
          chmod +x tests/test_downstream.sh
          ./tests/test_downstream.sh

      # Upload integration test logs for debugging failures
      # Only uploads on failure to conserve artifact storage space
      - name: Upload Downstream Logs (on failure)
        if: failure()
        timeout-minutes: 5
        uses: actions/upload-artifact@v4
        with:
          name: downstream-test-logs-debug
          path: downstream-logs/**/*.log
          if-no-files-found: warn
